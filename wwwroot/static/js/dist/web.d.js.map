{"version":3,"sources":["webpack:///webpack/bootstrap 9bb1b2fc1f2cb98cc92a","webpack:///./wwwroot/static/js/web.js","webpack:///./wwwroot/static/js/hive/web_game.js","webpack:///./wwwroot/static/js/hive/core/hive_core.js","webpack:///./wwwroot/static/js/common/event_emitter.js","webpack:///./wwwroot/static/js/common/utils.js","webpack:///./wwwroot/static/js/common/point_utils.js","webpack:///./wwwroot/static/js/constant/coordinate.js","webpack:///./wwwroot/static/js/hive/core/hive_movement.js","webpack:///./wwwroot/static/js/constant/game.js","webpack:///./wwwroot/static/js/hive/player/human_player.js","webpack:///./wwwroot/static/js/hive/view/web/board_view.js","webpack:///./wwwroot/static/js/common/canvas_utils.js","webpack:///./wwwroot/static/js/common/dom_utils.js","webpack:///./wwwroot/static/js/hive/view/web/toolbar_view.js","webpack:///./wwwroot/static/js/hive/view/web/sample_chesses.js","webpack:///./wwwroot/static/js/dnd/dnd_core.js","webpack:///./wwwroot/static/js/dnd/dnd_backend_mouse.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACXA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,0BAAyB,+BAA+B;AACxD;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7IA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,iEAAgE,SAAS;AACzE,iEAAgE,UAAU;AAC1E;AACA,qDAAoD,qCAAqC;AACzF;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,4CAA2C,gCAAgC;AAC3E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAqC;;AAErC;AACA,QAAO,IAAI;;AAEX;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;;;;;;ACvMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,iEAAgE,oBAAoB,EAAE;AACtF;;AAEA,oBAAmB,SAAS;AAC5B,0DAAyD,gBAAgB,EAAE;AAC3E;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA,sCAAqC,kBAAkB,EAAE;AACzD,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,6CAA4C,cAAc;AAC1D,MAAK;AACL,IAAG;;AAEH;AACA;AACA,iCAAgC,cAAc;AAC9C,MAAK;;AAEL;AACA;AACA,gEAA+D;AAC/D;AACA,MAAK,GAAG,qBAAqB;AAC7B,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,gBAAe,aAAa;AAC5B,sBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9NA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B,mCAAmC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpLA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC,kCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA,mCAAkC,qCAAqC;AACvE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,oBAAoB,EAAE;AAC/C;AACA;AACA,8BAA6B,gBAAgB;AAC7C;AACA;AACA,+BAA8B,kDAAkD;AAChF;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA,8BAA6B,2BAA2B;;AAExD;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA4D,wBAAwB,EAAE;AACtF;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK,0BAA0B,aAAa,EAAE;AAC9C,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,sCAAqC,6BAA6B;;AAElE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B,QAAQ;AACtC;;AAEA;AACA,+BAA8B,eAAe;AAC7C;;AAEA;AACA,+BAA8B,qBAAqB;AACnD;;AAEA;AACA,gCAA+B;AAC/B;;AAEA;AACA,iCAAgC;AAChC;;AAEA;AACA,+BAA8B,QAAQ;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,gCAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;;;;;AC5VA;AACA,QAAO,0BAA0B;AACjC,QAAO;AACP;;AAEA;AACA,kBAAiB,oBAAoB,KAAK,kCAAkC;AAC5E,kBAAiB,oBAAoB,KAAK,kCAAkC;AAC5E,kBAAiB,4BAA4B,KAAK,0BAA0B;AAC5E,kBAAiB,uBAAuB,KAAK,+BAA+B;AAC5E,kBAAiB,uBAAuB,KAAK;AAC7C;AACA,kBAAiB,yBAAyB,KAAK,+BAA+B;AAC9E,kBAAiB,wBAAwB,KAAK,gCAAgC;AAC9E,kBAAiB,wBAAwB,KAAK;AAC9C;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC5BA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA2C,uBAAuB;AAClE,MAAK;AACL;AACA;AACA;AACA,4CAA2C,uBAAuB;AAClE,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAU,gCAAgC;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA,oDAAmD,mBAAmB;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA8D,4BAA4B;AAC1F;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;;;;;;ACrOA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAiD,WAAW;AAC5D;;AAEA;AACA,gDAA+C,oBAAoB,EAAE;AACrE;AACA,IAAG;AACH;AACA,EAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1IA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,SAAS,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,yCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wDAAuD,eAAe;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,4BAA4B;AAChE;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;;;;;;ACxJA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC,4BAA4B;AAC5D;AACA,IAAG;;AAEH;AACA;AACA,EAAC;;AAED;;;;;;;AC1CA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA,qCAAoC,eAAe,OAAO,mBAAmB;;AAE7E;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gDAA+C,mBAAmB;AAClE,IAAG;AACH;AACA,oDAAmD,mBAAmB;AACtE,+DAA8D,iBAAiB;AAC/E,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpHA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,SAAS;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"web.d.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9bb1b2fc1f2cb98cc92a\n **/","var gameFactory = require('./hive/web_game');\n\nvar game = gameFactory({\n  document: document,\n  $boardContainer: document.getElementById('canvas_container'),\n  $toolbarContainers: [\n    document.getElementById('bar1'),\n    document.getElementById('bar2')\n  ]\n});\n\nconsole.log(game);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/web.js\n ** module id = 1\n ** module chunks = 0\n **/","var coreFactory    = require('./core/hive_core');\nvar humanPlayer    = require('./player/human_player');\nvar boardFactory   = require('./view/web/board_view');\nvar toolbarFactory = require('./view/web/toolbar_view');\nvar sampleChesses  = require('./view/web/sample_chesses');\n\nvar x           = require('../common/utils');\nvar dnd         = require('../dnd/dnd_core');\nvar dndBackend  = require('../dnd/dnd_backend_mouse');\n\nvar CG = require('../constant/game');\n\nvar gameFactory = function (options) {\n  var opts = Object.assign({\n    document: null,\n    $boardContainer: null,\n    $toolbarContainers: [],\n    playertypes: [CG.PLAYER_TYPE.HUMAN.ID, CG.PLAYER_TYPE.HUMAN.ID]\n  }, options);\n\n  if (opts.playertypes.length !== 2) {\n    throw new Error('Game Factory: must have two players');\n  }\n\n  if (!x.and(opts.playertypes.map(function (type) {\n    return [0, 1, 2].indexOf(type) !== -1;\n  }))) {\n    throw new Error('Game Factory: invalid player type');\n  }\n\n  // initialize dnd\n  var dndInstance = dnd({$container: opts.document.body});\n  dndInstance.backend(dndBackend());\n\n  // initialize core\n  var core = coreFactory({\n    coordinates: opts.coordinates\n  }, {\n    extension: false\n  });\n\n  // initialize board view\n  var vBoard = boardFactory({\n    document: opts.document,\n    $container: opts.$boardContainer,\n    dnd: dndInstance,\n    game: null,\n    samples: sampleChesses,\n    radius: 30,\n    coordinates: core.coordinates(),\n    canMove: function (sideId) {\n      return core.canMove(sideId);\n    }\n  });\n\n  core.on('NEW_MOVEMENT', function (data) {\n    vBoard.update(data);\n  });\n\n  vBoard.init();\n\n  // initialize players\n  var participants  = [];\n  var vToolbars     = [];\n\n  opts.playertypes.map(function (type, sideId) {\n    var chair = core.register(sideId);\n    var vToolbar = toolbarFactory({\n      document: opts.document,\n      $container: opts.$toolbarContainers[sideId],\n      dnd: dndInstance,\n      samples: sampleChesses,\n      sideId: sideId,\n      inventory: chair.inventory(),\n      isYourTurn: sideId === 0,\n      canMove: function () {\n        return chair.canMove();\n      }\n    });\n    var player;\n\n    if (type === CG.PLAYER_TYPE.HUMAN.ID) {\n      player = humanPlayer({\n        chair: chair\n      });\n\n      player.on('UPDATE_POSSIBLE_MOVE', function (data) {\n        vBoard.setAvailables(data.availables);\n      });\n      vToolbar.on('START_PLACE_' + sideId, function (data) {\n        player.mayPlace(data.roleId);\n      });\n      vBoard.on('START_MOVE_' + sideId, function (data) {\n        player.mayMove(data.src);\n      });\n      vBoard.on('MOVE_' + sideId, function (data) {\n        player.move(data.src, data.dst);\n      });\n      vBoard.on('PLACE_' + sideId, function (data) {\n        player.place(data.roleId, data.dst);\n      });\n      vBoard.addHumanControl(sideId);\n      vToolbar.addHumanControl(sideId);\n    } else if (type === CG.PLAYER_TYPE.REMOTE.ID) {\n      player = null;\n    } else if (type === CG.PLAYER_TYPE.AI.ID) {\n      player = null;\n    }\n\n    chair.on('TOGGLE_YOUR_TURN', function (data) {\n      if (data.on) {\n        player.prepareMove(data);\n        vToolbars[sideId].enable();\n      } else {\n        player.wait(data);\n        vToolbars[sideId].disable();\n      }\n    });\n\n    chair.on('INVENTORY_UPDATE', function (data) {\n      vToolbar.setInventory(data.inventory);\n    });\n\n    participants.push({\n      player: player,\n      chair: chair\n    });\n\n    vToolbars.push(vToolbar);\n\n    vToolbar.init();\n  });\n\n  return {\n    vBoard: vBoard,\n    vToolbars: vToolbars,\n    participants: participants,\n    core: core\n  };\n};\n\nmodule.exports = gameFactory;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/web_game.js\n ** module id = 2\n ** module chunks = 0\n **/","var Eventer = require('../../common/event_emitter');\nvar x = require('../../common/utils');\nvar pu = require('../../common/point_utils');\nvar m = require('./hive_movement');\n\nvar d3 = pu.d3;\n\nvar calcInventory = function (board, coordinates, extension) {\n  var initial = x.repeat(2, [1, 3, 3, 2, 2]);\n\n  coordinates.forEach(function (c) {\n    var info = d3.getPoint(board, c);\n    initial[info.sideId][info.roleId] --;\n\n    if (initial[info.sideId][info.roleId]) {\n      throw new Error('calcInventory: inventory cannot be negative number');\n    }\n  });\n\n  return initial;\n};\n\nvar coreFactory = function (store, options) {\n  var data = store || {};\n  var opts = Object.assign({\n    extension: false\n  }, options);\n  var coordinates, board;\n\n  var movements = data.movements || [];\n  var inventories = [];\n  var registered = [];\n\n  var setCoordinates = function (coords) {\n    coordinates = coords || [];\n    board = pu.convert.ns3InfoListToD3(\n      x.pluck('point', coordinates),\n      coordinates\n    );\n  };\n\n  setCoordinates(data.coordinates);\n  inventories = calcInventory(board, coordinates, opts.extension);\n\n  var stepCount = function () {\n    return movements.length;\n  };\n\n  var cloneData = function () {\n    return {\n      board: x.deepClone(board),\n      coordinates: x.deepClone(coordinates),\n      movements: x.deepClone(movements)\n    };\n  };\n\n  var notifyBoard = function (name, data) {\n    core.emit(name, data);\n  };\n\n  var notifyPlayer = function (sideId, name, data) {\n    registered.forEach(function (side) {\n      if (sideId !== side.sideId) return;\n      side.emit(name, data);\n    });\n  };\n\n  var notify = function (sideId, isPlace) {\n    notifyBoard('NEW_MOVEMENT', cloneData());\n    notifyPlayer(sideId,     'TOGGLE_YOUR_TURN', Object.assign({on: true},  cloneData()));\n    notifyPlayer(1 - sideId, 'TOGGLE_YOUR_TURN', Object.assign({on: false}, cloneData()));\n    if (isPlace) {\n      notifyPlayer(1 - sideId, 'INVENTORY_UPDATE', { inventory: inventories[1 - sideId] });\n    }\n  };\n\n  var fns = {\n    inventory: function (sideId) {\n      return inventories[sideId];\n    },\n    canMove: function (sideId) {\n      if (registered.length !== 2)  return false;\n      if (stepCount() === 0)        return sideId === 0;\n      return x.last(movements).sideId === 1 - sideId;\n    },\n    possiblePlacement: function (sideId) {\n      if (!fns.canMove(sideId)) return null;\n      return m.guessPlace(coordinates, sideId);\n    },\n    possibleMovement: function (sideId, src) {\n      if (!fns.canMove(sideId)) return null;\n      var roleId = d3.getPoint(board, src).roleId;\n      return m.guessMove(board, src, roleId);\n    },\n    place: function (sideId, roleId, dst) {\n      if (!fns.canMove(sideId)) {\n        throw new Error('CANNOT MOVE');\n      }\n\n      if (!m.checkPlace(board, sideId, dst)) {\n        throw new Error('INVALID PLACEMENT');\n      }\n\n      if (inventories[sideId][roleId] <= 0) {\n        throw new Error('OUT OF INVENTORY');\n      }\n\n      // modify board\n      var info   = pu.d3.getPoint(board, dst);\n      var zIndex = info ? (info.zIndex + 1) : 1;\n\n      inventories[sideId][roleId]--;\n      coordinates.push({\n        sideId: sideId,\n        roleId: roleId,\n        zIndex: zIndex,\n        point:  dst\n      });\n      setCoordinates(coordinates);\n\n      // update movements\n      movements.push({\n        type: 0,\n        sideId: sideId,\n        roleId: roleId,\n        src: null,\n        dst: dst\n      });\n\n      notify(1 - sideId, true);\n    },\n    move: function (sideId, src, dst) {\n      if (!fns.canMove(sideId)) {\n        throw new Error('CANNOT MOVE');\n      }\n\n      if (!m.checkMove(board, sideId, src, dst)) {\n        throw new Error('INVALID MOVEMENT');\n      }\n\n      // modify board\n      var info     = pu.d3.getPoint(board, dst);\n      var zIndex   = info ? (info.zIndex + 1) : 1;\n      var coord    = pu.d3.getPoint(board, src);\n\n      coord.point  = dst;\n      coord.zIndex = zIndex;\n      setCoordinates(coordinates);\n\n      // update movements\n      movements.push({\n        type: 1,\n        sideId: sideId,\n        roleId: coord.roleId,\n        src: src,\n        dst: dst\n      });\n\n      notify(1 - sideId, false);\n    }\n  };\n\n  var core = Eventer({\n    coordinates: function () {\n      return x.deepClone(coordinates);\n    },\n    canMove: function (sideId) {\n      return fns.canMove(sideId);\n    },\n    register: function (sideId) {\n      if (registered.find(function (item) { return item.sideId === sideId })) {\n        throw new Error('Game Register: players already full');\n      }\n\n      if ([0, 1].indexOf(sideId) === -1) {\n        throw new Error('Game Register: invalid sideId');\n      }\n\n      var obj = Object.keys(fns).reduce(function (prev, cur) {\n        var fn = fns[cur];\n\n        prev[cur] = fn.length > 1\n                      ? x.partial(fn)(sideId)\n                      : function () { return fn(sideId) };\n\n        return prev;\n      }, {});\n\n      obj.sideId = sideId;\n      obj = Eventer(obj);\n\n      registered.push(obj);\n      return obj;\n    }\n  });\n\n  return core;\n};\n\nmodule.exports = coreFactory;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/core/hive_core.js\n ** module id = 3\n ** module chunks = 0\n **/","var _EventEmitter = function (_target) {\n  var target = _target || {};\n  var events = {};\n\n  var on = function (name, fn, once) {\n    var removeFn = function (name, fnGetter) {\n      return function () {\n        if (!events[name])  return;\n        var index = events[name].indexOf(fnGetter());\n        events[name].splice(index, 1);\n      };\n    };\n    var onceWrap = function (fn, remove) {\n      return function () {\n        var args = [].slice.apply(arguments);\n        fn.apply(null, args);\n        remove();\n      };\n    };\n\n    var remove = removeFn(name, function () {\n      return fn;\n    });\n\n    if (once) {\n      fn = onceWrap(fn, remove);\n    }\n\n    events[name] = events[name] || [];\n    events[name].push(fn);\n\n    return remove;\n  };\n\n  var off = function (name) {\n    events[name] = [];\n  };\n\n  var emit = function (name, ev) {\n    if (!events[name])  return;\n    events[name].forEach(function (fn) {\n      fn(ev);\n    });\n  };\n\n  return Object.assign(target, {\n    on: function (name, fn) {\n      return on(name, fn);\n    },\n    off: function (name) {\n      return off(name);\n    },\n    once: function (name, fn) {\n      return on(name, fn, true);\n    },\n    emit: function (name, ev) {\n      return emit(name, ev);\n    }\n  });\n};\n\nmodule.exports = _EventEmitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/common/event_emitter.js\n ** module id = 4\n ** module chunks = 0\n **/","var partial = function (fn) {\n  var len = fn.length;\n  var arbitary;\n\n  arbitary = function (curArgs, leftArgCnt) {\n    return function () {\n      var args = [].slice.apply(arguments);\n\n      if (args.length >= leftArgCnt) {\n        return fn.apply(null, curArgs.concat(args));\n      }\n\n      return arbitary(curArgs.concat(args), leftArgCnt - args.length);\n    }\n  };\n\n  return arbitary([], len);\n};\n\nvar x = {\n  compose: function () {\n    var fns = [].slice.apply(arguments);\n    return fns.reduceRight(function (prev, cur) {\n      return function (arg) {\n        return cur(prev(arg));\n      };\n    })\n  },\n\n  partial: partial,\n\n  last: function (list) {\n    if (!list) {\n      throw new Error('Last: not a list');\n    }\n\n    return list[list.length - 1];\n  },\n\n  map: partial(function (fn, list) {\n    return list.map(fn);\n  }),\n\n  filter: partial(function (predicate, list) {\n    return list.filter(predicate);\n  }),\n\n  zipWith: function (fn) {\n    var lists = [].slice.call(arguments, 1);\n    var len   = Math.min.apply(null, lists.map(function (list) { return list.length; }));\n    var ret   = [];\n\n    for (var i = 0; i < len; i++) {\n      ret.push(fn.apply(null, lists.map(function (list) { return list[i]; })));\n    }\n\n    return ret;\n  },\n\n  zipWith2: partial(function (fn, list1, list2) {\n    return x.zipWith(fn, list1, list2);\n  }),\n\n  pluck: partial(function (key, list) {\n    return list.map(function (item) { return item[key]; });\n  }),\n\n  repeat: function (n, x) {\n    var ret = [];\n    var duplicate = function (item) {\n      if (Array.isArray(item))  return item.slice();\n      return item;\n    };\n\n    for (var i = 0; i < n; i++) {\n      ret.push(duplicate(x));\n    }\n    return ret;\n  },\n\n  loop: function (list, count) {\n    count = count || 1;\n    return list.slice(count).concat(list.slice(0, count));\n  },\n\n  equal: function (x, y) {\n    return x === y;\n  },\n\n  and: function (args) {\n    return args.reduce(function (prev, cur) {\n      return prev && cur;\n    }, true);\n  },\n\n  or: function (args) {\n    return args.reduce(function (prev, cur) {\n      return prev || cur;\n    }, false);\n  },\n\n  multi: partial(function (x, y) {\n    return x * y;\n  }),\n\n  add: partial(function (x, y) {\n    return x + y;\n  }),\n\n  flatten: function (list) {\n    return [].concat.apply([], list);\n  },\n\n  time: function (comment, fn) {\n    return function () {\n      var args = [].slice.apply(arguments);\n      var start, duration;\n\n      start = new Date() * 1;\n      var result = fn.apply(null, args);\n      duration = new Date() * 1 - start;\n      console.log(comment, duration, 'ms');\n      return result;\n    };\n  },\n\n  sprintf: function (str, data) {\n    return Object.keys(data).reduce(function (prev, cur) {\n      return prev.replace(new RegExp('\\\\$\\\\{' + cur + '\\\\}', 'g'), data[cur]);\n    }, str);\n  },\n\n  maxBy: function (options) {\n    var opts = Object.assign({\n      compare: function (a, b) { return a < b; }\n    }, options);\n\n    return opts.list.reduce(function (prev, cur, i) {\n      if (!opts.predicate(cur)) return prev;\n      if (opts.compare(prev.ret, opts.getter(cur, i))) return {ret: cur, index: i};\n      return prev;\n    }, {ret: null, index: -1});\n  },\n\n  product: function () {\n    var args = [].slice.apply(arguments);\n    var promiseArray = function (item) {\n      return Array.isArray(item) ? item : [item];\n    };\n    var flatten = function (list) {\n      return [].concat.apply([], list);\n    };\n\n    return args.reduce(function (prev, cur) {\n      return !prev ? cur : flatten(prev.map(function (item1) {\n        return cur.map(function (item2) {\n          return promiseArray(item1).concat(promiseArray(item2));\n        });\n      }));\n    }, null);\n  },\n\n  permute: function (list) {\n    var permutation = function (n) {\n      var helper = function (n, seq, result) {\n        if (seq.length >= n) {\n          result.push(seq);\n          return result;\n        }\n\n        for (var i = 0; i < n; i++) {\n          if (seq.indexOf(i) === -1) {\n            result = helper(n, seq.concat([i]), result);\n          }\n        }\n\n        return result;\n      };\n      return helper(n, [], []);\n    };\n\n    return permutation(list.length).map(function (seq) {\n      return seq.map(function (index) {\n        return list[index];\n      });\n    });\n  },\n\n  // C (2, N)\n  combination2: function (list) {\n    var len = list.length;\n    var ret = [];\n    var i, j;\n\n    for (i = 0; i < len - 1; i++) {\n      for (j = i + 1; j < len; j++) {\n        ret.push([list[i], list[j]]);\n      }\n    }\n\n    return ret;\n  },\n\n  findValue: function (object, path, value) {\n    var tokens = path.split('.');\n    var follow = function (object, keys) {\n      return  keys.reduce(function (prev, cur) {\n        return prev && prev[cur];\n      }, object);\n    };\n\n    return Object.keys(object).reduce(function (prev, cur) {\n      return prev || (follow(object[cur], tokens) === value ? object[cur] : null);\n    }, null);\n  },\n\n  deepClone: function (data) {\n    // FIXME: should recursively parse data\n    return JSON.parse(JSON.stringify(data));\n  }\n};\n\nmodule.exports = x;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/common/utils.js\n ** module id = 5\n ** module chunks = 0\n **/","var x = require('./utils');\nvar CC = require('../constant/coordinate');\n\n// Note: use hash table to remove duplicates for performance\nvar uniquePoints = function (points) {\n  var result = [];\n  var dict = {};\n  var hash = function (point) { return x.flatten(point).join('-'); };\n\n  points.forEach(function (point) {\n    var key = hash(point);\n    if (!dict[key]) {\n      dict[key] = true;\n      result.push(point);\n    }\n  });\n\n  return result;\n};\n\nvar ns3 = {\n  addPoint: x.zipWith2(x.zipWith2(x.add)),\n\n  negPoint: x.map(x.map(x.multi(-1))),\n\n  samePoint: x.partial(function (p1, p2) {\n    return x.and(x.zipWith2(function (xs, ys) {\n      return x.and(x.zipWith2(x.equal, xs, ys))\n    }, p1, p2));\n  }),\n\n  uniquePoints: uniquePoints\n};\n\nvar d2 = {\n  addPoint: x.zipWith2(x.add),\n\n  negPoint: x.map(x.multi(-1)),\n\n  uniquePoints: uniquePoints,\n\n  /*\n   * Test whether a point is in a hexagon\n   */\n\n  inHexagon: function (d2Center, radius, pos) {\n    var lineFx = function (p1, p2) {\n      var k = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n\n      if (Math.abs(k) === Infinity) return p2[0];\n\n      var x1 = p1[0];\n      var y1 = p1[1];\n\n      return function (x) {\n        return k * x + (y1 - k * x1);\n      };\n    };\n\n    var test = x.partial(function (point, fx, predicate) {\n      if (typeof fx === 'number')  return predicate === Math.sign(point[0] - fx);\n      return predicate === Math.sign(point[1] - fx(point[0]));\n    });\n\n    var adjusted = x.compose(\n      d2.negPoint,\n      x.map(x.multi(2 / radius)),\n      d2.addPoint(d2.negPoint(d2Center))\n    )(pos);\n\n    var d2HexagonPoints = x.map(convert.ns3ToD2, CC.NS3_UNIT_HEXAGON_POINTS);\n    var fxs = x.zipWith(\n      lineFx,\n      x.loop(d2HexagonPoints, 1),\n      d2HexagonPoints\n    );\n    var predicates = [-1, -1, -1, 1, 1, 1];\n    var result = x.zipWith(test(adjusted), fxs, predicates);\n\n    return x.and(result);\n  }\n};\n\n/*\n * 3 Dimension Hexagon Axis Functions\n * eg. [x, y, z]\n *\n *       X  --------  -Z\n *         /        \\\n *    -Y  /          \\  Y\n *        \\          /\n *         \\        /\n *       Z  --------  -X\n *\n */\n\nvar d3 = {\n  addPoint: x.zipWith2(x.add),\n\n  negPoint: x.map(x.multi(-1)),\n\n  samePoint: x.partial(function (p1, p2) {\n    if (!p1 || !p2) return false;\n    return x.and(x.zipWith2(x.equal, p1, p2));\n  }),\n\n  uniquePoints: uniquePoints,\n\n  around: function (triple) {\n    return x.permute([-1, 0, 1]).map(x.zipWith2(x.add, triple));\n  },\n\n  setPoint: function (data, triple, value) {\n    var entry = data;\n\n    triple.forEach(function (index, i) {\n      if (i < 2) {\n        entry[index] = entry[index] || {};\n        entry = entry[index];\n      } else {\n        // sort by zIndex\n        entry[index] = entry[index] ? entry[index].concat([value]) : [value];\n        entry[index] = entry[index].sort(function (a, b) {\n          return b.zIndex - a.zIndex;\n        });\n      }\n    });\n  },\n\n  getPoint: x.partial(function (data, triple) {\n    if (!triple)  return null;\n\n    var ret = triple.reduce(function (prev, cur) {\n      return prev && prev[cur];\n    }, data);\n\n    // return the topmost element;\n    return ret && ret[0];\n  })\n};\n\nvar convert = {\n  ns3ToD2: function (point) {\n    return x.map(function (z) {\n      return z[0] + z[1] * Math.sqrt(3);\n    }, point);\n  },\n\n  ns3ToD3: function (point2d) {\n    var x = point2d[0][0];\n    var y = point2d[1][1];\n    return [\n      (x / 3 + y) / (-2),\n      x / 3,\n      (y - x / 3) / 2\n    ];\n  },\n\n  d3ToNs3: function (point3d) {\n    var x = point3d[0];\n    var y = point3d[1];\n    // var z = point3d[2];\n\n    return [[3 * y, 0], [0, -2 * x - y]];\n  },\n\n  ns3InfoListToD3: function (points, pinfos) {\n    var ret = {};\n    points.forEach(function (point, i) {\n      d3.setPoint(ret, point, pinfos[i]);\n    });\n    return ret;\n  }\n};\n\nmodule.exports = {\n  ns3: ns3,\n  d3: d3,\n  d2: d2,\n  convert: convert\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/common/point_utils.js\n ** module id = 6\n ** module chunks = 0\n **/","var radiusFactor = 1 / 2;\n\nvar unitHexagonPoints = [\n  [[-2, 0], [0,  0]],\n  [[-1, 0], [0,  1]],\n  [[1,  0], [0,  1]],\n  [[2,  0], [0,  0]],\n  [[1,  0], [0, -1]],\n  [[-1, 0], [0, -1]]\n];\n\nvar unitCenterDistance = [\n  [[0,  0], [0,  2]],\n  [[3,  0], [0,  1]],\n  [[3,  0], [0, -1]],\n  [[0,  0], [0, -2]],\n  [[-3, 0], [0, -1]],\n  [[-3, 0], [0,  1]]\n];\n\nmodule.exports = {\n  RADIUS_FACTOR: radiusFactor,\n  NS3_UNIT_HEXAGON_POINTS: unitHexagonPoints,\n  NS3_UNIT_CENTER_OFFSETS: unitCenterDistance\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/constant/coordinate.js\n ** module id = 7\n ** module chunks = 0\n **/","var x  = require('../../common/utils');\nvar pu = require('../../common/point_utils');\nvar CC = require('../../constant/coordinate');\nvar CG = require('../../constant/game');\n\nvar d3 = pu.d3;\nvar convert = pu.convert;\nvar ROLE = CG.ROLE;\n\nvar d3UnitCenterDistance = CC.NS3_UNIT_CENTER_OFFSETS.map(convert.ns3ToD3);\n\nvar aroundDirections = function (d3point, d3Index) {\n  var isOccupied = function (point) {\n    return !!d3.getPoint(d3Index, point);\n  };\n\n  return d3.around(d3point)\n          .filter(isOccupied)\n          .map(d3.addPoint(d3.negPoint(d3point)));\n};\n\nvar brokenAroundDirectionCombinations = function (d3point, d3Index) {\n  var existedDirectionIndexes = aroundDirections(d3point, d3Index)\n                                .map(function (direction) {\n                                  return d3UnitCenterDistance.findIndex(function (d) {\n                                    return d3.samePoint(direction, d);\n                                  });\n                                })\n                                .sort();\n\n  console.log('aroundDirection in broken', aroundDirections(d3point, d3Index));\n  console.log('d3Unit', d3UnitCenterDistance);\n\n  var grouped = existedDirectionIndexes.reduce(function (prev, cur) {\n    var lastGroup  = prev[prev.length - 1];\n    var firstGroup = prev[0];\n    var last       = lastGroup && lastGroup[lastGroup.length - 1];\n    var first      = firstGroup && firstGroup[0];\n\n    console.log('first, last', first, last);\n    if (lastGroup === undefined) return [[cur]];\n    if (last  === cur - 1) {\n      lastGroup.push(cur);\n      return prev;\n    }\n\n    if (first === (cur + 1) % d3UnitCenterDistance.length) {\n      firstGroup.push(cur);\n      return prev;\n    }\n\n    return prev.concat([[cur]]);\n  }, []);\n\n  console.log('grouped', grouped);\n\n  grouped = x.pluck(0, grouped);\n\n  return x.combination2(\n    grouped.map(function (index) { return d3UnitCenterDistance[index] })\n  );\n};\n\nvar brokenAroundPointCombinations = function (d3point, d3Index) {\n  var result = brokenAroundDirectionCombinations(d3point, d3Index);\n  return !result.length ? [] : x.map(x.map(d3.addPoint(d3point)))(result);\n};\n\nvar filterKeepOneHive = x.time('filterKeepOneHive', function (d3Index, d3origin, availables) {\n  console.log('!!!!!!!!!!!! filterKeepOneHive !!!!!!!!!!');\n  console.log('availables, ' , availables);\n  var __d3GetPoint = function (data, triple, level) {\n    if (!triple)  return null;\n\n    var ret = triple.reduce(function (prev, cur) {\n      return prev && prev[cur];\n    }, data);\n\n    return ret && ret[level || 0];\n  };\n\n  // pretend that the movement is complete\n  var _d3GetPoint = function (d3Index, d3point, d3target) {\n    if (d3.samePoint(d3point, d3target)) return __d3GetPoint(d3Index, d3origin);\n    if (d3.samePoint(d3point, d3origin)) return __d3GetPoint(d3Index, d3origin, 1);\n    return __d3GetPoint(d3Index, d3point);\n  };\n\n  var isConnected = function (d3p1, d3p2, d3target) {\n    var isOccupied = function (d3point) {\n      return !!_d3GetPoint(d3Index, d3point, d3target);\n    };\n    var aroundOccupied = function (d3point) {\n      return d3.around(d3point).filter(isOccupied);\n    };\n\n    var helper = function (current, target, visited) {\n      // console.log('helper', arguments);\n      if (d3.samePoint(current, target)) return true;\n      visited.push(current);\n\n      return x.or(aroundOccupied(current).filter(function (point) {\n        return !visited.find(function (p) {\n          return d3.samePoint(p, point);\n        });\n      }).map(function (point) {\n        return helper(point, target, visited);\n      }));\n    };\n\n    return helper(d3p1, d3p2, []);\n  };\n\n  var brokenCombinations = brokenAroundPointCombinations(d3origin, d3Index);\n  if (brokenCombinations.length === 0)  return availables;\n\n  var check = function (d3target) {\n    return x.and(brokenCombinations.map(function (tuple) {\n      console.log('????????????? in brokenCombinations loop ???????????');\n      return isConnected(tuple[0], tuple[1], d3target);\n    }));\n  };\n\n  if (check(null))  return availables;\n  return availables.filter(check);\n});\n\nvar directionBesides = function (direction) {\n  var index = d3UnitCenterDistance.findIndex(d3.samePoint(direction));\n\n  if (index === -1) {\n    throw new Error('direction invalid', direction);\n  }\n\n  var len = d3UnitCenterDistance.length;\n  var prevIndex = (index - 1 + len) % len;\n  var nextIndex = (index + 1) % len;\n\n  return [d3UnitCenterDistance[prevIndex], d3UnitCenterDistance[nextIndex]];\n};\n\nvar walkOneStep = function (options) {\n  var opts = options || {};\n  console.log('walkOneStep', opts);\n\n  return function (base, d3point, d3Index, options) {\n    var neighbors = d3.around(d3point).filter(function (point) {\n      return !!d3.getPoint(d3Index, point);\n    });\n\n    return d3.around(d3point).filter(function (point) {\n      if (d3.getPoint(d3Index, point)) return false;\n\n      var arounds = d3.around(point);\n      var shareNeighbors = arounds.filter(function (subPoint) {\n        if (d3.samePoint(subPoint, base))  return false;\n        return neighbors.find(function (neighbor) {\n          return d3.samePoint(subPoint, neighbor);\n        });\n      });\n\n      if (shareNeighbors < 1) return false;\n      if (opts.skipNarrow)    return true;\n\n      // test narrow\n      var direction  = d3.addPoint(point, d3.negPoint(d3point));\n      var besides    = directionBesides(direction);\n      var inNarrow   = x.compose(\n        function (list) { return x.and(list); },\n        x.map(\n          x.compose(\n            function (info) { return !!info },\n            d3.getPoint(d3Index),\n            // should not count basePoint as a narrow boundary\n            function (point) { return d3.samePoint(base, point) ? null : point },\n            d3.addPoint(d3point)\n          )\n        )\n      )(besides);\n\n      return !inNarrow;\n    });\n  };\n};\n\nvar climbOneStep = function () {\n  return function (base, d3point, d3Index) {\n    return d3.around(d3point).filter(function (point) {\n      if (d3.samePoint(point, base)) return false;\n      return !!d3.getPoint(d3Index, point);\n    });\n  };\n};\n\nvar guess = function (oneStep, d3point, d3Index, options) {\n  var opts = Object.assign({\n    step: 1\n  }, options);\n  var helper = function (oneStep, base, d3point, d3Index, step, result) {\n    if (step === 0) return result;\n\n    var list = oneStep(base, d3point, d3Index).filter(function (point) {\n      return !result.find(function (item) {\n        return item.list.find(function (found) {\n          return d3.samePoint(found, point);\n        });\n      })\n    });\n\n    if (list.length === 0)  return result;\n    result = result.concat([{left: step - 1, list: list}]);\n\n    list.forEach(function (point) {\n      result = helper(oneStep, base, point, d3Index, step - 1, result);\n    });\n\n    return result;\n  };\n\n  var ret = helper(oneStep, d3point, d3point, d3Index, opts.step, []);\n  return ret;\n};\n\nvar MOVEMENT = {\n  WALK: function (opts, d3point, d3Index) {\n    var result = guess(walkOneStep(), d3point, d3Index, opts);\n    if (opts.exact) result = result.filter(function (item) { return item.left === 0; });\n    return x.flatten(x.pluck('list', result));\n  },\n  JUMP: function (options, d3point, d3Index) {\n    return d3UnitCenterDistance.map(function (forward) {\n      var next = d3.addPoint(d3point, forward);\n      var bank = null;\n\n      while (d3.getPoint(d3Index, next)) {\n        bank = next;\n        next = d3.addPoint(next, forward);\n      }\n\n      return bank ? next : null;\n    }).filter(function (item) { return item; });\n  },\n  CLIMB: function (options, d3point, d3Index) {\n    var opts = Object.assign({\n      step: 1\n    }, options);\n    var pinfo = d3.getPoint(d3Index, d3point);\n    console.log('climb zIndex', pinfo.zIndex, pinfo.role);\n\n    var result1 = guess(climbOneStep(), d3point, d3Index, opts);\n    var result2 = guess(walkOneStep({skipNarrow: pinfo.zIndex > 1}),  d3point, d3Index, opts);\n\n    return [].concat(\n      x.flatten(x.pluck('list', result1)),\n      x.flatten(x.pluck('list', result2))\n    );\n  }\n};\n\n/*\n * Factory for Hive6 Controller\n */\n\nvar guessMove = function (roleId, point, d3Index) {\n  console.log(arguments);\n  var result;\n\n  switch (roleId) {\n    case ROLE.BEE.ID:\n      result = MOVEMENT.WALK({step: 1}, point, d3Index);\n      break;\n\n    case ROLE.ANT.ID:\n      result = MOVEMENT.WALK({step: Infinity}, point, d3Index);\n      break;\n\n    case ROLE.SPIDER.ID:\n      result = MOVEMENT.WALK({step: 3, exact: true}, point, d3Index);\n      break;\n\n    case ROLE.GRASSHOPPER.ID:\n      result = MOVEMENT.JUMP({}, point, d3Index);\n      break;\n\n    case ROLE.BEETLE.ID:\n      result = MOVEMENT.CLIMB({}, point, d3Index);\n      break;\n\n    default:\n      result = MOVEMENT.WALK({step: 1}, point, d3Index);\n  }\n\n  return filterKeepOneHive(d3Index, point, result);\n};\n\nvar guessPlace = function (coordinates, sideId) {\n  var onSide = x.partial(function (sideId, coord) {\n    return coord.sideId === sideId;\n  });\n  var findCoord = function (point) {\n    return coordinates.find(function (coord) {\n      return pu.d3.samePoint(coord.point, point);\n    });\n  };\n\n  // no chess on board\n  if (coordinates.length === 0) {\n    return [[0, 0, 0]];\n  }\n\n  // no our side's chess on board\n  if (coordinates.filter(onSide(sideId)).length === 0) {\n    return x.compose(\n      pu.d3.uniquePoints,\n      x.flatten,\n      x.map(pu.d3.around),\n      x.pluck('point')\n    )(coordinates);\n  }\n\n  // normal cases\n  return x.compose(\n    x.filter(function (point) {\n      return !pu.d3.around(point).find(function (sub) {\n        var found = findCoord(sub);\n        return found && found.sideId === 1 - sideId;\n      });\n    }),\n    x.filter(function (point) { return !findCoord(point) }),\n    pu.d3.uniquePoints,\n    x.flatten,\n    x.map(pu.d3.around),\n    x.pluck('point'),\n    x.filter(onSide(sideId))\n  )(coordinates)\n};\n\nmodule.exports = {\n  guessPlace: guessPlace,\n  guessMove: function (board, point, roleId) {\n    return guessMove(roleId, point, board);\n  },\n  checkPlace: function () {\n    return true;\n  },\n  checkMove: function () {\n    return true;\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/core/hive_movement.js\n ** module id = 8\n ** module chunks = 0\n **/","var SIDE = {\n  ME: { ID: 0, COLOR: '#f5e8bb' },\n  OP: { ID: 1, COLOR: '#666' }\n};\n\nvar ROLE = {\n  BEE:          { ID: 0, IMG: 'bee_${side}.png',         IMGSIZE: [71, 56] },\n  ANT:          { ID: 1, IMG: 'ant_${side}.png',         IMGSIZE: [66, 75] },\n  GRASSHOPPER:  { ID: 2, IMG: 'grasshopper_${side}.png', IMGSIZE: [54, 83] },\n  SPIDER:       { ID: 3, IMG: 'spider_${side}.png',      IMGSIZE: [71, 77] },\n  BEETLE:       { ID: 4, IMG: 'beetle_${side}.png',      IMGSIZE: [51, 79] }\n  /*\n  MOSQUITO:     { ID: 5, IMG: 'mosquito_${side}.png'    , IMGSIZE: [88, 84]  },\n  LADYBUG:      { ID: 6, IMG: 'ladybug_${side}.png'     , IMGSIZE: [90, 108] },\n  PILLBUG:      { ID: 7, IMG: 'pillbug_${side}.png'     , IMGSIZE: [87, 111] }\n  */\n};\n\nvar PLAYER_TYPE = {\n  HUMAN:  { ID: 0 },\n  REMOTE: { ID: 1 },\n  AI:     { ID: 2 }\n};\n\nmodule.exports = {\n  SIDE: SIDE,\n  ROLE: ROLE,\n  PLAYER_TYPE: PLAYER_TYPE\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/constant/game.js\n ** module id = 9\n ** module chunks = 0\n **/","var Eventer = require('../../common/event_emitter');\n\nvar humanPlayer = function (options) {\n  var opts = Object.assign({\n    chair: null\n  }, options);\n\n  if (!opts.chair) {\n    throw new Error('Human Player: chair is required');\n  }\n\n  var player = Eventer({\n    mayMove: function (src) {\n      if (!opts.chair.canMove()) return;\n      var availables = opts.chair.possibleMovement(src);\n      player.emit('UPDATE_POSSIBLE_MOVE', {availables: availables});\n    },\n    mayPlace: function () {\n      if (!opts.chair.canMove()) return;\n      var availables = opts.chair.possiblePlacement();\n      player.emit('UPDATE_POSSIBLE_MOVE', {availables: availables});\n    },\n    prepareMove: function () {\n      // Human do nothing in prepareMove\n    },\n    wait: function () {\n      // Human do nothing in wait\n    },\n    move: function (src, dst) {\n      if (!opts.chair.canMove()) return;\n      return opts.chair.move(src, dst);\n    },\n    place: function (roleId, dst) {\n      if (!opts.chair.canMove()) return;\n      return opts.chair.place(roleId, dst);\n    }\n  });\n\n  return player;\n};\n\nmodule.exports = humanPlayer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/player/human_player.js\n ** module id = 10\n ** module chunks = 0\n **/","var x  = require('../../../common/utils');\nvar pu = require('../../../common/point_utils');\nvar cu = require('../../../common/canvas_utils');\nvar du = require('../../../common/dom_utils');\nvar CG = require('../../../constant/game');\nvar CC = require('../../../constant/coordinate');\nvar Eventer = require('../../../common/event_emitter');\n\nvar ROLE = CG.ROLE;\nvar SIDE = CG.SIDE;\n\nvar boardFactory = function (_opts) {\n  var opts = Object.assign({\n    document: null,\n    $container: null,\n    dnd: null,\n    samples: null,\n    radius: 30,\n    coordinates: null,\n    canMove: null\n  }, _opts);\n  var radius = opts.radius;\n\n  var origin        = null;\n  var $canvas       = null;\n  var ctx           = null;\n  var humanSideIds  = [];\n  var availables    = [];\n  var coordinates   = null;\n\n  var update = function (data, noRender) {\n    coordinates = data.coordinates || [];\n    if (!noRender)  _render();\n  };\n\n  update({ coordinates: opts.coordinates }, true);\n  /*\n   * Board Helper Functions\n   */\n  var transform = null;\n\n  var _init = function () {\n    var width  = parseInt(du.getStyle(opts.$container, 'width'), 10);\n    var height = parseInt(du.getStyle(opts.$container, 'height'), 10);\n    $canvas = opts.document.createElement('canvas');\n    $canvas.width  = width;\n    $canvas.height = height;\n    du.setStyle($canvas, {\n      width:  width + 'px',\n      height: height + 'px'\n    });\n    ctx    = $canvas.getContext('2d');\n    origin = [[width / 2, 0], [height / 2, 0]];\n    opts.$container.appendChild($canvas);\n\n    transform = x.compose(\n      pu.convert.ns3ToD2,\n      pu.ns3.addPoint(origin),\n      x.map(x.map(x.multi(radius * CC.RADIUS_FACTOR))),\n      pu.convert.d3ToNs3\n    );\n\n    opts.dnd.addSource({\n      $dom: $canvas,\n      onDragStart: function (ev) {\n        var index = coordinates.findIndex(function (coord) {\n          return pu.d2.inHexagon(transform(coord.point), radius, [ev.localX, ev.localY]);\n        });\n        var found = coordinates[index];\n\n        if (!found) return false;\n        if (!opts.canMove(found.sideId))  return false;\n\n        vBoard.emit('START_MOVE_' + found.sideId, { src: found.point });\n        found.isDragging = true;\n        setTimeout(_render);\n\n        return [\n          opts.samples[found.sideId][found.roleId],\n          {\n            sideId: found.sideId,\n            roleId: found.roleId,\n            from: 'board',\n            originPos: found.point,\n            boardIndex: index\n          }\n        ];\n      },\n      onDragEnd: function (ev) {\n        coordinates[ev.dragging.type.boardIndex].isDragging = false;\n        setTimeout(_render);\n      }\n    });\n\n    opts.dnd.addTarget({\n      $dom: $canvas,\n      onMove: function (ev) {\n        /*\n        if (!ev.dragging) return;\n        if (isDragging) return;\n        isDragging = true;\n\n        var type = ev.dragging.type;\n        var onSide = x.partial(function (sideId, item, i) {\n          return coordinates[i].side === sideId;\n        });\n\n        if (type.boardIndex === undefined) {\n          // Dragging from toolbar\n          if (points.length === 0) {\n            availables = [[0, 0, 0]].map(pu.convert.d3ToNs3);\n          } else if (points.filter(onSide(type.sideId)).length === 0) {\n            availables = x.compose(pu.d3.uniquePoints, x.flatten)(\n              points.map(pu.convert.ns3ToD3).map(pu.d3.around)\n            ).map(pu.convert.d3ToNs3);\n          } else {\n            availables = x.compose(pu.d3.uniquePoints, x.flatten)(\n              points.filter(onSide(type.sideId)).map(pu.convert.ns3ToD3).map(pu.d3.around)\n            ).filter(function (coord) {\n              if (pu.d3.getPoint(d3Index, coord)) return false;\n              return !pu.d3.around(coord).find(function (subCoord) {\n                var pinfo = pu.d3.getPoint(d3Index, subCoord);\n                return pinfo && pinfo.side === 1 - type.sideId;\n              })\n            }).map(pu.convert.d3ToNs3);\n          }\n        } else {\n          // Dragging from board\n          availables = movement(type.roleId, pu.convert.ns3ToD3(type.originPos), d3Index);\n        }\n\n        _render();\n        */\n      },\n      onDragLeave: function (ev) {\n        // isDragging = false;\n        // _render();\n      },\n      onDrop: function (ev) {\n        var dst = availables.find(function (point) {\n          return pu.d2.inHexagon(transform(point), radius, [ev.localX, ev.localY]);\n        });\n\n        if (!dst) {\n          _render();\n          return false;\n        }\n\n        if (!ev.dragging) return false;\n        if (humanSideIds.indexOf(ev.dragging.type.sideId) === -1) return false;\n\n        if (ev.dragging.type.boardIndex !== undefined) {\n          vBoard.emit('MOVE_' + ev.dragging.type.sideId, {\n            src: ev.dragging.type.originPos,\n            dst: dst\n          });\n        } else {\n          vBoard.emit('PLACE_' + ev.dragging.type.sideId, {\n            roleId: ev.dragging.type.roleId,\n            dst: dst\n          });\n        }\n\n        availables = [];\n        setTimeout(_render);\n        return true;\n      }\n    });\n  };\n\n  var _render = function () {\n    cu.clearCanvas(ctx);\n\n    coordinates.map(function (coord, i) {\n      return i;\n    }).sort(function (a, b) {\n      return coordinates[a].zIndex - coordinates[b].zIndex;\n    }).forEach(function (i) {\n      var coord = coordinates[i];\n      var side  = x.findValue(SIDE, 'ID', coord.sideId);\n      var role  = x.findValue(ROLE, 'ID', coord.roleId);\n\n      cu.marginHexagon(ctx, {\n        center: transform(coord.point),\n        radius: radius,\n        margin: 1,\n        fillStyle: coord.isDragging ? 'rgba(149, 145, 145, 0.5)' : side.COLOR,\n        image: coord.isDragging ? null : x.sprintf(role.IMG, {side: side.ID ? 'op' : 'me'}),\n        imageSize: role.IMGSIZE,\n        text: i\n      });\n    });\n\n    availables.forEach(function (point) {\n      cu.marginHexagon(ctx, {\n        center: transform(point),\n        radius: radius,\n        margin: 1,\n        fillStyle: 'rgba(186, 250, 66, 0.5)'\n      });\n    });\n  };\n\n  /*\n   * instance returned\n   */\n  var vBoard = Eventer({\n    init: function () {\n      _init();\n      _render();\n    },\n    render: function () {\n      _render();\n    },\n    update: function (data) {\n      return update(data);\n    },\n    setAvailables: function (list) {\n      availables = list;\n      _render();\n    },\n    addHumanControl: function (sideId) {\n      humanSideIds.push(sideId);\n    }\n  });\n\n  return vBoard;\n};\n\nmodule.exports = boardFactory;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/view/web/board_view.js\n ** module id = 11\n ** module chunks = 0\n **/","/* global Image */\n\nvar x = require('./utils');\nvar pu = require('./point_utils');\nvar CC = require('../constant/coordinate');\nvar CG = require('../constant/game');\n\nvar setContext = function (ctx, list) {\n  var old = list.map(function (tuple) {\n    return [tuple[0], ctx[tuple[0]]];\n  });\n  var change = function (ctx, list) {\n    list.forEach(function (tuple) {\n      ctx[tuple[0]] = tuple[1];\n    });\n  };\n\n  change(ctx, list);\n  return function () {\n    change(ctx, old);\n  };\n};\n\nvar clearCanvas = function (ctx) {\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n};\n\n/*\n * Draw Hexagon on Canvas, based on a N(sqrt3) center point.\n */\n\nvar hexagon = function (ctx, pCenter, radius, isStroke) {\n  var points = x.map(\n    x.compose(\n      pu.d2.addPoint(pCenter),\n      pu.convert.ns3ToD2,\n      x.map(x.map(x.multi(radius * CC.RADIUS_FACTOR)))\n    ),\n    CC.NS3_UNIT_HEXAGON_POINTS\n  );\n\n  ctx.beginPath();\n  ctx.moveTo.apply(ctx, points[points.length - 1]);\n\n  points.forEach(function (point) {\n    ctx.lineTo.apply(ctx, point);\n  });\n\n  ctx.closePath();\n\n  if (isStroke) {\n    ctx.stroke()\n  } else {\n    ctx.fill();\n  }\n};\n\nvar imgUrl = function (imageName) {\n  return '/static/img/pieces/' + imageName;\n};\n\nvar calcRect = function (center, sideMax, size) {\n  var ratio = sideMax / Math.max.apply(null, size);\n  var tsize = x.map(x.multi(ratio), size);\n  return {\n    top: center[1] - tsize[1] / 2,\n    left: center[0] - tsize[0] / 2,\n    width: tsize[0],\n    height: tsize[1]\n  };\n};\n\nvar drawChessImage = function (ctx, center, radius, image, size) {\n  var sideMax = Math.sqrt(3) * radius * 0.7;\n  var rect = calcRect(center, sideMax, size);\n  var $img = ROLE_IMAGES[image];\n  var draw = function () {\n    ctx.drawImage($img, rect.left, rect.top, rect.width, rect.height);\n  };\n\n  if ($img.loaded) {\n    draw();\n  } else {\n    $img.addEventListener('load', draw);\n  }\n};\n\nvar marginHexagon = function (ctx, options) {\n  var opts = Object.assign({\n    fillStyle: '#666',\n    marginStyle: 'rgb(255, 255, 255)',\n    center: [100, 100],\n    radius: 50,\n    margin: 3\n  }, options);\n\n  var resetStyle = setContext(ctx, [\n    ['fillStyle', opts.fillStyle],\n    ['strokeStyle', opts.marginStyle],\n    ['lineWidth', opts.margin]\n  ]);\n\n  hexagon(ctx, opts.center, opts.radius);\n  hexagon(ctx, opts.center, opts.radius - Math.floor(opts.margin / 2 - 0.1), true);\n\n  /*\n  if (opts.text !== undefined) {\n    resetFontStyle = setContext(ctx, [['fillStyle', '#000']]);\n    console.log(opts.text,  opts.center[0], opts.center[1])\n    ctx.fillText(opts.text, opts.center[0], opts.center[1]);\n    resetFontStyle();\n  }\n  */\n\n  if (opts.image && opts.imageSize) {\n    drawChessImage(ctx, opts.center, opts.radius, opts.image, opts.imageSize);\n  }\n\n  resetStyle();\n};\n\nvar ROLE_IMAGES = Object.keys(CG.ROLE).reduce(function (prev, cur) {\n  ['me', 'op'].forEach(function (type) {\n    var imageName = x.sprintf(CG.ROLE[cur].IMG, {side: type});\n    var $img = new Image();\n\n    $img.src = imgUrl(imageName);\n    $img.addEventListener('load', function () { this.loaded = true; });\n    prev[imageName] = $img;\n  });\n  return prev;\n}, {});\n\nmodule.exports = {\n  setContext: setContext,\n  marginHexagon: marginHexagon,\n  clearCanvas: clearCanvas,\n  imgUrl: imgUrl\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/common/canvas_utils.js\n ** module id = 12\n ** module chunks = 0\n **/","/* global getComputedStyle */\n\nmodule.exports = {\n  setStyle: function ($dom, style) {\n    Object.keys(style).forEach(function (key) {\n      $dom.style[key] = style[key];\n    });\n  },\n\n  getStyle: function (dom, styleName) {\n    if (!dom)   throw new Error('getStyle: dom not exist');\n    return getComputedStyle(dom)[styleName];\n  },\n\n  mousePosition: function (dom, ev) {\n    var rect = dom.getBoundingClientRect();\n    return [\n      ev.clientX - rect.left,\n      ev.clientY - rect.top\n    ];\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/common/dom_utils.js\n ** module id = 13\n ** module chunks = 0\n **/","var x  = require('../../../common/utils');\nvar pu = require('../../../common/point_utils');\nvar cu = require('../../../common/canvas_utils');\nvar du = require('../../../common/dom_utils');\nvar CG = require('../../../constant/game');\nvar Eventer = require('../../../common/event_emitter');\n\nvar ROLE = CG.ROLE;\nvar SIDE = CG.SIDE;\n\nvar toolbarFactory = function (options) {\n  var opts = Object.assign({\n    dnd: null,\n    samples: null,\n    $container: null,\n    inventory: null,\n    sideId: null\n  }, options);\n  var inventory = opts.inventory;\n  var $canvas   = null;\n  var ctx       = null;\n  var playerCommonStyle = {\n    position: 'absolute',\n    top: '15px',\n    width: '150px',\n    height: '560px',\n    border: '1px solid #ccc'\n  };\n  var playerConfig = { style: { left: '15px' }, title: '' };\n  var offsetX = 30;\n  var offsetY = 80;\n  var radius = 30;\n  var centers = inventory.map(function (c, index) {\n    return [offsetX + radius, offsetY + 2 * radius * index];\n  });\n  var humanSideIds = [];\n  var isYourTurn = opts.isYourTurn;\n\n  var pos2roleId = function (x, y) {\n    return centers.findIndex(function (center) {\n      return pu.d2.inHexagon(center, radius, [x, y]);\n    });\n  };\n\n  var _init = function () {\n    $canvas = (function () {\n      var $dom = document.createElement('canvas');\n      du.setStyle($dom, Object.assign({}, playerCommonStyle, playerConfig.style));\n      opts.$container.appendChild($dom);\n\n      opts.dnd.addSource({\n        $dom: $dom,\n        onDragStart: function (ev) {\n          if (humanSideIds.indexOf(opts.sideId) === -1) return null;\n          if (!opts.canMove())  return null;\n\n          var roleId = pos2roleId(ev.localX, ev.localY);\n          if (roleId === -1) return null;\n          if (inventory[roleId] <= 0) return null;\n\n          vToolbar.emit('START_PLACE_' + opts.sideId, {roleId: roleId});\n\n          return [\n            opts.samples[opts.sideId][roleId],\n            {\n              sideId: opts.sideId,\n              roleId: roleId,\n              from: 'toolbar',\n              originPos: null\n            }\n          ];\n        },\n        onDragEnd: function (ev) {\n          // if (!ev.success || !ev.dragging) return;\n          // opts.inventory[i][ev.dragging.type.roleId] --;\n          // _renderPlayers();\n        }\n      });\n\n      return $dom;\n    })();\n\n    ctx = $canvas.getContext('2d');\n    _renderPlayer();\n  };\n\n  var _renderPlayer = function () {\n    var reset;\n\n    ctx.canvas.width  = parseInt(playerCommonStyle.width, 10);\n    ctx.canvas.height = parseInt(playerCommonStyle.height, 10);\n\n    du.setStyle(ctx.canvas, {\n      backgroundColor: isYourTurn ? 'rgb(203, 249, 186)' : 'transparent'\n    });\n\n    // Render Title\n    reset = cu.setContext(ctx, [\n      ['font', '20px serif'],\n      ['fillStyle', '#333']\n    ]);\n\n    ctx.fillText(playerConfig.title, 10, 30);\n    reset();\n\n    // Render Available Chess\n    inventory.forEach(function (count, roleId) {\n      var side = x.findValue(SIDE, 'ID', opts.sideId);\n      var role = x.findValue(ROLE, 'ID', roleId);\n\n      cu.marginHexagon(ctx, {\n        center: centers[roleId],\n        radius: radius,\n        fillStyle: count > 0 ? side.COLOR : '#ccc',\n        image: x.sprintf(role.IMG, {side: side.ID ? 'op' : 'me'}),\n        imageSize: role.IMGSIZE\n      });\n\n      var reset = cu.setContext(ctx, [\n        ['fillStyle', count > 0 ? '#f00' : '#ccc'],\n        ['font', ' 20px bold']\n      ]);\n\n      ctx.fillText('x ' + count, centers[roleId][0] + radius + 20, centers[roleId][1] + 10);\n      reset();\n    });\n  };\n\n  var vToolbar = Eventer({\n    init: function () {\n      return _init();\n    },\n    setInventory: function (_inventory) {\n      inventory = _inventory;\n      _renderPlayer();\n    },\n    addHumanControl: function (sideId) {\n      humanSideIds.push(sideId);\n    },\n    enable: function () {\n      isYourTurn = true;\n      _renderPlayer();\n    },\n    disable: function () {\n      isYourTurn = false;\n      _renderPlayer();\n    }\n  });\n\n  return vToolbar;\n};\n\nmodule.exports = toolbarFactory;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/view/web/toolbar_view.js\n ** module id = 14\n ** module chunks = 0\n **/","var x  = require('../../../common/utils');\nvar du = require('../../../common/dom_utils');\nvar cu = require('../../../common/canvas_utils');\nvar CG = require('../../../constant/game');\n\nvar SIDE = CG.SIDE;\nvar ROLE = CG.ROLE;\n\nvar sampleChesses = x.product(Object.keys(SIDE), Object.keys(ROLE)).reduce(function (prev, tuple, i) {\n  var CANVAS_WIDTH = 60;\n  var CANVAS_HEIGHT = 60;\n  var side = SIDE[tuple[0]];\n  var role = ROLE[tuple[1]];\n\n  var $canvas = document.createElement('canvas');\n  var ctx = $canvas.getContext('2d');\n  $canvas.width  = CANVAS_WIDTH;\n  $canvas.height = CANVAS_HEIGHT;\n  du.setStyle($canvas, {\n    pointerEvents: 'none',\n    position: 'absolute',\n    display: 'none',\n    top: '0',\n    left: CANVAS_WIDTH * i + 'px',\n    width: CANVAS_WIDTH + 'px',\n    height: CANVAS_HEIGHT + 'px'\n  });\n  document.body.appendChild($canvas);\n\n  cu.marginHexagon(ctx, {\n    center: [CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2],\n    radius: CANVAS_WIDTH / 2,\n    fillStyle: side.COLOR,\n    margin: 1,\n    image: x.sprintf(role.IMG, {side: side.ID ? 'op' : 'me'}),\n    imageSize: role.IMGSIZE\n  });\n\n  prev[side.ID][role.ID] = $canvas;\n  return prev;\n}, [new Array(Object.keys(ROLE).length), new Array(Object.keys(ROLE).length)]);\n\nmodule.exports = sampleChesses;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/hive/view/web/sample_chesses.js\n ** module id = 15\n ** module chunks = 0\n **/","var x = require('../common/utils');\nvar du = require('../common/dom_utils');\n\nvar dnd = function (opts) {\n  var backend;\n  var destroyBackend;\n  var $inHand;\n  var sources = [];\n  var targets = [];\n  var isDragging = false;\n  var dragging = null;\n  var sourceTuples;\n  var targetTuples;\n\n  var hook = function () {\n    backend.bindEvent(opts.$container, onMove(null), onDragEnd(null), sourceGetter, targetGetter);\n  };\n  var sourceGetter = function (reset) {\n    if (reset || !sourceTuples) {\n      sourceTuples = sources.map(function (source) {\n        return [source.$dom, onDragStart(source), onDragEnd(source)];\n      });\n    }\n    return sourceTuples;\n  };\n  var targetGetter = function (reset) {\n    if (reset || !targetTuples) {\n      targetTuples = targets.map(function (target) {\n        return [target.$dom, onMove(target), onDrop(target), onDragLeave(target)];\n      });\n    }\n    return targetTuples;\n  };\n  var onDragStart = x.partial(function (source, ev) {\n    var tuple, type, $tmp;\n\n    tuple = source.onDragStart(ev);\n    if (!tuple) return;\n\n    $tmp = tuple[0];\n    type = tuple[1];\n    isDragging = true;\n\n    dragging = {\n      source: source,\n      type: type\n    };\n\n    if ($tmp) {\n      $inHand = $tmp;\n      if ($inHand.parentNode.tagName.toLowerCase() !== 'body') {\n        document.body.appendChild($inHand);\n      }\n    }\n  });\n  var onDragEnd = x.partial(function (source, ev) {\n    var s = source || (dragging && dragging.source);\n\n    if (!isDragging)  return;\n\n    if ($inHand) {\n      du.setStyle($inHand, {\n        display: 'none'\n      });\n      $inHand = null;\n    }\n\n    s && s.onDragEnd(Object.assign({success: false}, ev, {dragging: dragging}));\n\n    isDragging = false;\n    dragging = null;\n  });\n  var onMove = x.partial(function (target, ev) {\n    var inHandWidth, inHandHeight;\n\n    if ($inHand) {\n      inHandWidth  = parseInt(du.getStyle($inHand, 'width'), 10);\n      inHandHeight = parseInt(du.getStyle($inHand, 'height'), 10);\n      du.setStyle($inHand, {\n        position: 'fixed',\n        zIndex: '9999',\n        display: 'block',\n        top: (ev.clientY - inHandWidth  / 2) + 'px',\n        left: (ev.clientX - inHandHeight / 2) + 'px'\n      });\n    }\n\n    if (!isDragging)  return;\n    target && target.onMove(Object.assign(ev, {dragging: dragging}));\n  });\n  var onDrop = x.partial(function (target, ev) {\n    var success = target.onDrop(Object.assign(ev, {dragging: dragging}));\n    dragging && onDragEnd(dragging.source, Object.assign(ev, {success: success}));\n  });\n  var onDragLeave = x.partial(function (target, ev) {\n    target.onDragLeave(ev);\n  });\n\n  return {\n    addSource: function (source) {\n      sources.push(source);\n      sourceGetter(true);\n    },\n    addTarget: function (target) {\n      targets.push(target);\n      targetGetter(true);\n    },\n    backend: function (_backend) {\n      backend = _backend;\n      destroyBackend && destroyBackend();\n      destroyBackend = null;\n      hook();\n    }\n  };\n};\n\nmodule.exports = dnd;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/dnd/dnd_core.js\n ** module id = 16\n ** module chunks = 0\n **/","var du = require('../common/dom_utils');\n\nvar dndBackendMouse = function () {\n  // Note: Getter returns an array of triples, triples as [$dom, fn, fn], while fn is called with eventObject\n  var sourceGetter, targetGetter;\n  var onDragMove, onDragEnd;\n  var $container;\n  var unbind;\n\n  var inDom = function ($top, $holder, $sub) {\n    var $dom = $sub;\n\n    while ($dom) {\n      if ($dom === $holder)  return true;\n      if ($sub === $top) return false;\n      $dom = $dom.parentNode;\n    }\n\n    return false;\n  };\n  var onMouseDown = function (ev) {\n    var i, len, pos, $dom, onDragStart;\n    var triples = sourceGetter && sourceGetter();\n\n    if (!triples) return;\n\n    for (i = 0, len = triples.length; i < len; i++) {\n      $dom = triples[i][0];\n      onDragStart = triples[i][1];\n\n      if (inDom($container, $dom, ev.target)) {\n        pos = du.mousePosition($dom, ev);\n        ev.localX = pos[0];\n        ev.localY = pos[1];\n        onDragStart(ev);\n        break;\n      }\n    }\n  };\n  var onMouseUp = function (ev) {\n    var i, len, pos, $dom, onDrop;\n    var triples = targetGetter && targetGetter();\n\n    if (!triples) return;\n\n    for (i = 0, len = triples.length; i < len; i++) {\n      $dom = triples[i][0];\n      onDrop = triples[i][2];\n\n      if (inDom($container, $dom, ev.target)) {\n        pos = du.mousePosition($dom, ev);\n        ev.localX = pos[0];\n        ev.localY = pos[1];\n        onDrop(ev);\n        break;\n      }\n    }\n\n    onDragEnd(ev);\n  };\n  var $lastOver = null;\n  var onMouseMove = function (ev) {\n    var i, len, pos, $dom, onMove, onDragLeave, found;\n    var triples = targetGetter && targetGetter();\n    if (!triples) return;\n\n    for (i = 0, len = triples.length; i < len; i++) {\n      $dom = triples[i][0];\n      onMove = triples[i][1];\n      onDragLeave = triples[i][3];\n\n      if (inDom($container, $dom, ev.target)) {\n        pos = du.mousePosition($dom, ev);\n        ev.localX = pos[0];\n        ev.localY = pos[1];\n        found = true;\n        $lastOver = $dom;\n        onMove(ev);\n      } else if ($lastOver === $dom) {\n        $lastOver = null;\n        onDragLeave && onDragLeave(ev);\n      }\n    }\n\n    if (found)  return;\n    onDragMove(ev);\n  };\n\n  return {\n    bindEvent: function (_$container, _onDragMove, _onDragEnd, _sourceGetter, _targetGetter) {\n      unbind && unbind();\n      sourceGetter = _sourceGetter;\n      targetGetter = _targetGetter;\n      onDragMove = _onDragMove;\n      onDragEnd  = _onDragEnd;\n      $container = _$container;\n      _$container.addEventListener('mousedown', onMouseDown);\n      _$container.addEventListener('mouseup', onMouseUp);\n      _$container.addEventListener('mousemove', onMouseMove);\n      unbind = function () {\n        _$container.removeEventListener('mousedown', onMouseDown);\n        _$container.removeEventListener('mouseup', onMouseUp);\n        _$container.removeEventListener('mousemove', onMouseMove);\n      };\n      return unbind;\n    }\n  };\n};\n\nmodule.exports = dndBackendMouse;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./wwwroot/static/js/dnd/dnd_backend_mouse.js\n ** module id = 17\n ** module chunks = 0\n **/"],"sourceRoot":""}